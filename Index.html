<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jump ‚Äî HTML only</title>
<style>
  :root {
    --bg: #0f1226;
    --fg: #eaf2ff;
    --accent: #7dd3fc;
    --accent2: #a7f3d0;
    --danger: #ff7b7b;
  }

  html, body {
    height: 100%;
    margin: 0;
    background: radial-gradient(1000px 700px at 70% -10%, #1a1f48, var(--bg));
    color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
  }

  /* Layout */
  .wrap {
    max-width: 720px;
    margin: 0 auto;
    padding: 12px;
    display: grid;
    gap: 12px;
  }

  header {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 12px;
  }

  h1 {
    font-size: clamp(20px, 2.8vw, 28px);
    margin: 8px 0;
    letter-spacing: .5px;
  }

  .hud {
    display: flex;
    gap: 12px;
    align-items: center;
    opacity: .9;
    user-select: none;
  }
  .pill {
    padding: 6px 10px;
    border-radius: 999px;
    background: rgba(255,255,255,.06);
    border: 1px solid rgba(255,255,255,.08);
    font-variant-numeric: tabular-nums;
  }

  /* Canvas container with nice frame */
  .stage {
    position: relative;
    border-radius: 14px;
    overflow: hidden;
    box-shadow:
      0 10px 30px rgba(0,0,0,.35),
      inset 0 0 0 1px rgba(255,255,255,.08);
    background:
      linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0)) 0 0/100% 60px no-repeat,
      radial-gradient(900px 600px at 30% -10%, #1a2358 0%, #0f1226 60%, #0a0d1f 100%);
  }
  canvas { display: block; width: 100%; height: auto; }

  /* Overlay screens */
  .overlay {
    pointer-events: none;
    position: absolute; inset: 0;
    display: grid; place-items: center;
    text-align: center;
  }
  .card {
    pointer-events: auto;
    backdrop-filter: blur(8px);
    background: rgba(8,12,30,.55);
    border: 1px solid rgba(255,255,255,.08);
    border-radius: 12px;
    padding: 16px 18px;
    max-width: min(90%, 520px);
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  .card h2 { margin: 6px 0 2px; font-size: 20px; }
  .muted { opacity: .8; font-size: 14px; }

  .row { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-top: 10px; }
  button {
    appearance: none; border: 0; cursor: pointer;
    padding: 10px 14px; border-radius: 10px;
    background: linear-gradient(180deg, #2c375f, #1b2448);
    color: var(--fg); font-weight: 600;
    border: 1px solid rgba(255,255,255,.1);
  }
  button:hover { filter: brightness(1.08); }
  button:active { transform: translateY(1px); }

  /* Mobile controls */
  .touch {
    position: absolute; inset: auto 0 0 0;
    display: none; justify-content: space-between; padding: 8px;
    gap: 8px;
  }
  .touch button { flex: 1; padding: 14px 0; font-size: 16px; }
  @media (pointer:none), (pointer:coarse) {
    .touch { display: flex; }
  }

  footer {
    opacity: .65;
    font-size: 12px;
    text-align: center;
    margin: 6px 0 10px;
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Jump</h1>
      <div class="hud">
        <div class="pill">Score :<span id="score">0</span></div>
        <div class="pill">Record :<span id="best">0</span></div>
      </div>
    </header>

    <div class="stage" id="stage">
      <canvas id="game" width="600" height="900" aria-label="Jeu Jump"></canvas>

      <!-- Overlays -->
      <div class="overlay" id="startScreen">
        <div class="card">
          <h2>Pr√™t ?</h2>
          <p class="muted">D√©place-toi avec <b>‚Üê ‚Üí</b> (ou <b>A/D</b>). Touche une plateforme pour rebondir et monte le plus haut possible.</p>
          <div class="row">
            <button id="btnStart">Lancer la partie (Entr√©e)</button>
          </div>
          <p class="muted">Astuce : l‚Äô√©cran ‚Äúscrolle‚Äù vers le bas quand tu montes. Si tu tombes sous le bas de l‚Äô√©cran ‚Üí <b style="color:var(--danger)">Game Over</b>.</p>
        </div>
      </div>

      <div class="overlay" id="gameOver" style="display:none">
        <div class="card">
          <h2>Perdu !</h2>
          <p class="muted">Score : <b id="finalScore">0</b> ‚Äî Record : <b id="finalBest">0</b></p>
          <div class="row">
            <button id="btnRetry">Rejouer (R)</button>
            <button id="btnShare">Partager le score</button>
          </div>
        </div>
      </div>

      <!-- Touch controls -->
      <div class="touch" aria-hidden="true">
        <button id="leftBtn">‚Üê</button>
        <button id="rightBtn">‚Üí</button>
      </div>
    </div>

    <footer>
      HTML/CSS/JS uniquement ‚Äì aucune d√©pendance. ¬© Toi üéÆ
    </footer>
  </div>

<script>
(() => {
  /*** Helpers ***************************************************************/
  const rand = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  /*** Canvas / sizing ********************************************************/
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const stageEl = document.getElementById('stage');

  // Keep a nice aspect ratio on resize
  function fitCanvas() {
    const w = stageEl.clientWidth;
    const h = w * 1.5; // 2:3 portrait
    canvas.style.height = h + 'px';
  }
  new ResizeObserver(fitCanvas).observe(stageEl); fitCanvas();

  /*** Game state *************************************************************/
  const G = 0.38;           // gravity
  const JUMP = 14.5;        // bounce strength
  const MOVE = 0.38;        // acceleration
  const FRICTION = 0.90;    // horizontal damping
  const WRAP = true;        // wrap around left/right edges
  const PLATFORM_W = [80, 160];
  const PLATFORM_H = 14;

  let keys = {left:false,right:false};
  let touchDir = 0; // -1 left, +1 right, 0 none
  let raf = null;

  const player = {
    x: canvas.width/2, y: canvas.height-80,
    vx: 0, vy: 0,
    r: 16, // radius
    alive: true
  };

  let cameraY = 0;      // how far we've scrolled up
  let score = 0;        // highest altitude reached
  let best = Number(localStorage.getItem('jump.best') || 0);

  const platforms = [];

  function makePlatform(y, x = rand(40, canvas.width-40), w = rand(...PLATFORM_W), moving=false) {
    return {
      x: x - w/2,
      y,
      w,
      h: PLATFORM_H,
      vx: moving ? rand(0.6, 1.2) * (Math.random()<.5?-1:1) : 0
    };
  }

  function reset() {
    // Base state
    player.x = canvas.width/2;
    player.y = canvas.height - 60;
    player.vx = 0; player.vy = 0; player.alive = true;
    cameraY = 0; score = 0;
    platforms.length = 0;

    // Seed initial platforms from bottom to top
    const gapMin = 70, gapMax = 110;
    let y = canvas.height - 30;
    while (y > -2000) {
      const moving = Math.random() < 0.12;
      platforms.push(makePlatform(y, undefined, rand(...PLATFORM_W), moving));
      y -= rand(gapMin, gapMax);
    }
    // Start screen UI
    updateHUD();
  }

  /*** Controls ***************************************************************/
  addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') keys.right = true;
    if (e.key === 'r') startGame();
    if (e.key === 'Enter') startGame();
  });
  addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') keys.right = false;
  });

  // Touch buttons
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');

  const press = (dir) => () => { touchDir = dir; };
  const releaseIf = (dir) => () => { if (touchDir === dir) touchDir = 0; };

  ['mousedown','touchstart'].forEach(ev=>{
    leftBtn.addEventListener(ev, press(-1)); rightBtn.addEventListener(ev, press(1));
  });
  ['mouseup','mouseleave','touchend','touchcancel'].forEach(ev=>{
    leftBtn.addEventListener(ev, releaseIf(-1)); rightBtn.addEventListener(ev, releaseIf(1));
  });

  /*** UI *********************************************************************/
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const startScreen = document.getElementById('startScreen');
  const gameOver = document.getElementById('gameOver');
  const finalScore = document.getElementById('finalScore');
  const finalBest = document.getElementById('finalBest');
  document.getElementById('btnStart').addEventListener('click', startGame);
  document.getElementById('btnRetry').addEventListener('click', startGame);
  document.getElementById('btnShare').addEventListener('click', async () => {
    const text = `Mon score sur Jump: ${score} (record ${best})`;
    if (navigator.share) {
      try { await navigator.share({ text, title:'Jump' }); } catch(e){}
    } else {
      await navigator.clipboard.writeText(text);
      alert('Score copi√© dans le presse-papiers !');
    }
  });

  function updateHUD() {
    scoreEl.textContent = Math.floor(score);
    bestEl.textContent = Math.floor(best);
  }

  function showOverlay(which) {
    startScreen.style.display = (which === 'start') ? '' : 'none';
    gameOver.style.display = (which === 'over') ? '' : 'none';
  }

  /*** Game loop **************************************************************/
  function spawnMoreIfNeeded() {
    // Highest (smallest y) platform currently present
    let topY = Math.min(...platforms.map(p => p.y));
    const targetTop = cameraY - 2200; // keep ~2000px above the camera
    while (topY > targetTop) {
      const moving = Math.random() < clamp(0.08 + score/5000, 0.08, 0.35);
      const w = rand(PLATFORM_W[0], Math.max(PLATFORM_W[0], PLATFORM_W[1] - score/10));
      topY -= rand(70, 110);
      platforms.push(makePlatform(topY, undefined, w, moving));
    }
  }

  function physics(dt) {
    // Horizontal input
    const dir = (keys.right?1:0) - (keys.left?1:0) || touchDir;
    player.vx += dir * MOVE * dt;
    player.vx *= FRICTION;
    player.x += player.vx * dt;

    // Wrap around
    if (WRAP) {
      if (player.x < -player.r) player.x = canvas.width + player.r;
      if (player.x > canvas.width + player.r) player.x = -player.r;
    } else {
      player.x = clamp(player.x, player.r, canvas.width - player.r);
    }

    // Gravity
    player.vy += G * dt;
    let nextY = player.y + player.vy * dt;

    // Collisions (only when falling)
    if (player.vy > 0) {
      for (const p of platforms) {
        const withinX = player.x + player.r > p.x && player.x - player.r < p.x + p.w;
        const crossingY = player.y <= p.y - player.r && nextY > p.y - player.r;
        if (withinX && crossingY) {
          nextY = p.y - player.r;
          player.vy = -JUMP; // bounce
          break;
        }
      }
    }
    player.y = nextY;

    // Move platforms (moving ones bounce on edges)
    for (const p of platforms) {
      if (p.vx) {
        p.x += p.vx * dt;
        if (p.x < 0 || p.x + p.w > canvas.width) p.vx *= -1;
      }
    }

    // Camera follows the player upward
    if (player.y < canvas.height * 0.45) {
      const dy = canvas.height * 0.45 - player.y;
      player.y += dy;
      cameraY -= dy;
      score = Math.max(score, -cameraY | 0);
      updateHUD();
      spawnMoreIfNeeded();
    }

    // Remove platforms far below
    const minKeep = cameraY + canvas.height + 200;
    for (let i = platforms.length - 1; i >= 0; i--) {
      if (platforms[i].y > minKeep) platforms.splice(i, 1);
    }

    // Death: fell below the bottom
    if (player.y - player.r > canvas.height) {
      player.alive = false;
    }
  }

  function draw() {
    // Parallax background grid of stars
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const starCt = 60;
    ctx.globalAlpha = .6;
    for (let i=0;i<starCt;i++){
      const sx = (i*97 % canvas.width);
      const sy = (i*211 % (canvas.height*3)) + (cameraY*0.2 % (canvas.height*3));
      ctx.fillStyle = i%7===0 ? '#9bdcff' : '#ffffff';
      ctx.fillRect(sx, sy, 2, 2);
    }
    ctx.globalAlpha = 1;

    // Platforms
    for (const p of platforms) {
      const yOnScreen = p.y - cameraY;
      if (yOnScreen < -PLATFORM_H || yOnScreen > canvas.height + PLATFORM_H) continue;
      const grd = ctx.createLinearGradient(p.x, yOnScreen, p.x, yOnScreen + p.h);
      grd.addColorStop(0, '#7dd3fc'); grd.addColorStop(1, '#34d399');
      ctx.fillStyle = grd;
      // rounded rect
      const r = 6;
      ctx.beginPath();
      ctx.moveTo(p.x + r, yOnScreen);
      ctx.arcTo(p.x + p.w, yOnScreen, p.x + p.w, yOnScreen + p.h, r);
      ctx.arcTo(p.x + p.w, yOnScreen + p.h, p.x, yOnScreen + p.h, r);
      ctx.arcTo(p.x, yOnScreen + p.h, p.x, yOnScreen, r);
      ctx.arcTo(p.x, yOnScreen, p.x + p.w, yOnScreen, r);
      ctx.closePath();
      ctx.fill();
    }

    // Player (little capsule)
    const py = player.y - cameraY;
    ctx.save();
    ctx.translate(player.x, py);
    const tilt = clamp(player.vx * 0.03, -0.4, 0.4);
    ctx.rotate(tilt);
    // shadow
    ctx.globalAlpha = .25;
    ctx.beginPath();
    ctx.ellipse(0, 22, 14, 6, 0, 0, Math.PI*2);
    ctx.fillStyle = '#000'; ctx.fill();
    ctx.globalAlpha = 1;
    // body
    const grd = ctx.createLinearGradient(0, -18, 0, 18);
    grd.addColorStop(0, '#eaf2ff'); grd.addColorStop(1, '#b7c9ff');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.moveTo(-12, -18);
    ctx.quadraticCurveTo(0, -26, 12, -18);
    ctx.lineTo(12, 18);
    ctx.quadraticCurveTo(0, 26, -12, 18);
    ctx.closePath(); ctx.fill();
    // eye
    ctx.fillStyle = '#0f1226';
    ctx.beginPath(); ctx.arc(4, -6, 3, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Fixed timestep loop for consistent physics
  let last = performance.now();
  let acc = 0;
  const dtMs = 1000/60;

  function loop(now) {
    raf = requestAnimationFrame(loop);
    const delta = now - last; last = now; acc += delta;
    // Cap to avoid spiral of death if tab was hidden
    acc = Math.min(acc, 100);
    while (acc >= dtMs) {
      physics(1); // our physics uses "dt units" where 1 ~ 1/60s
      acc -= dtMs;
    }
    draw();

    if (!player.alive) {
      cancelAnimationFrame(raf); raf = null;
      best = Math.max(best, Math.floor(score));
      localStorage.setItem('jump.best', String(best));
      finalScore.textContent = Math.floor(score);
      finalBest.textContent = Math.floor(best);
      showOverlay('over');
    }
  }

  function startGame() {
    showOverlay(null);
    reset();
    if (!raf) { last = performance.now(); acc = 0; raf = requestAnimationFrame(loop); }
  }

  // Initial state
  reset();
  showOverlay('start');
})();
</script>
</body>
</html>
